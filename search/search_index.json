{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CTASM Docs Welcome to the CTASM documentation page Introduction CTASM is the low-level codegen for CTS , a scripting language designed with safety and ease of use in mind. It can do anything CTS can do and sometimes more efficient. It's similar to assembly language in the way it's written, but it's more user friendly and easier to understand. It also promotes safety unlike assembly. CTASM is, unlike its high-level counterpart, weakly typed and extremely simple. It can compile to either bytecode for the CTVM or native C code . Installation TODO: make Updating TODO: make Getting Started To get started writing CTASM code, visit the Getting Started page to learn all you need to begin coding in CTASM. Native Compilation While all the CT languages are designed for running on the CTVM as bytecode, this assembler also allows compiling to native C code for improved runtime. This is done by generating C functions with hardcoded CTVM functions and then linking it with a lightweight version of the VM. This ensures a speed increase in the program's runtime since it does not have to read and map the bytecode as the normal VM would.","title":"Home"},{"location":"#ctasm-docs","text":"Welcome to the CTASM documentation page","title":"CTASM Docs"},{"location":"#introduction","text":"CTASM is the low-level codegen for CTS , a scripting language designed with safety and ease of use in mind. It can do anything CTS can do and sometimes more efficient. It's similar to assembly language in the way it's written, but it's more user friendly and easier to understand. It also promotes safety unlike assembly. CTASM is, unlike its high-level counterpart, weakly typed and extremely simple. It can compile to either bytecode for the CTVM or native C code .","title":"Introduction"},{"location":"#installation","text":"TODO: make","title":"Installation"},{"location":"#updating","text":"TODO: make","title":"Updating"},{"location":"#getting-started","text":"To get started writing CTASM code, visit the Getting Started page to learn all you need to begin coding in CTASM.","title":"Getting Started"},{"location":"#native-compilation","text":"While all the CT languages are designed for running on the CTVM as bytecode, this assembler also allows compiling to native C code for improved runtime. This is done by generating C functions with hardcoded CTVM functions and then linking it with a lightweight version of the VM. This ensures a speed increase in the program's runtime since it does not have to read and map the bytecode as the normal VM would.","title":"Native Compilation"},{"location":"directives/","text":"","title":"Compiler Directives"},{"location":"gettingstarted/","text":"Hello World Your first program which prints hello world: #entry main #section data hello: str \"hello world\" println: str \"println\" #section code main: { move regA, println move regC, hello call move regE, 0 exit regE } Copy this code into hello.ctasm and compile with ctasm -c hello.ctasm && ./out . The -c flag means compile to native C. Congratulations! You just compiled and ran your first CTASM program; however, this code can be hard to comprehend for a beginner. Let's look deeper into the program, line by line: #entry main : This tells the VM what function to call at the start of your program. #section data : This declares all the code below it as \"data\", or static variables. More on sections will be explained later on. hello: str \"hello world\" : This makes a variable named hello of type string and the value \"hello world\". println: str \"println\" : This makes a variable named println of type string and the value \"println\". This is just used to store the println function name, as it's needed when calling it. #section code : This declared all the code below it as the actual program code. Functions and instructions are declared and written here. More on sections later on. main: { : This declares a function named main and opens a block for all instructions within this function. A block is just a simple {} , just like most other languages. move regA, println : This moves the println data into the A register, which is used for function calling. move regC, hello : This moves the hello data into the C register, which stores the first argument for println . Functions and calling conventions are explained in detail later on. call : This will search for and (if found) call the function whose name is stored in the A register. move regE, 0 : This just moves the 0 constant into the E register. exit regE : This exits the program with the code contained in the E register (in this case, 0). Exiting is required for CTASM programs; otherwise, the VM will complain. } : This marks the end of the main function. Compiling Multiple Files If you want to compile and use multiple files, you must simply provide them all in the ctasm command, and it will automatically compile and link each file to whatever your target output is. To use data and code from these other files, you don't have to do any importing since all files automatically include each other safely to make it even easier to use, but you can still implicitly say you're using a separate file by adding #using \"otherfile.ctasm\" at the top of your file using it. This just tells the compiler to error if the file isn't found in the list of files to compile. Sections CTASM uses sections to organize code into different sections. This is done in a similar manner to assembly which does the same thing. There are currently 2 different sections in CTASM: code and data . Data - is used to store any static variables in memory before the program even starts. The way this is actually done is dependant on what it compiles to and the implementation of said compiler. Code - is the only required section since it is used to define all the functions and instructions for your code. A section is declared using #section <name> . Detailed explanations of all sections . Compiler Directives Compiler directives are important pieces of code that are used to tell the compiler how to generate the code. This can be anything ranging from which specific version it's using and the entry function to the file name to use in the outputted code and what other files are being used. Directives are defined with a # followed by its name and argument(s). For directives, arguments are only separated by a space and an argument encased in double quotes (\"many words\") will count as one argument. Full list of directives . Comments // one line comment /* multi line comment */ Functions main: { move regA, \"add\" // function name move regC, 34 // x move regD, 35 // y call copy regE, regC move regA, \"println\" // print value call move regE, 0 exit regE } add: { // x, y add regC, regD // IMPORTANT: add here is the INSTRUCTION. it has NOTHING to do with the functions name copy regB, regE // conventions soon return } At their core, functions are really simple. They just run instructions. There's no automatic type checking or argument counting here without the use of some standard functions. However, you should still follow the calling convention and (optionally) declare the arguments in a comment. Technically , you can overload a function, but it completely overloads it, meaning the lowest definition of the function is the one used at the end. Hoisting Functions can be used before they're declared: add is declared after main , but is still being used within it. This is due to the VM loading all functions into memory before running. Calling Convention By default, the CTASM calling convention passes the first 4 arguments through registers C , D , F , and G in that order. Arguments beyond the fourth get pushed to the stack following a left-to-right order. If the function uses a variable number of arguments (REST parameters or varargs), they should be pushed onto the stack from left to right, followed by the count of REST parameters. Even when there's less than 4 regular arguments, REST parameters should still only be on the stack. REST parameters should always come after the normal arguments. The callee (the function being called) is always responsible for clearing the passed arguments and restoring the stack to its state before being called. This will optionally be enforced by the caller (the instruction doing the call). The caller may optionally allocate shadow space on the stack for the callee; however, if this is done, the caller is also responsible for removing this shadow space after the function call. If the function needs arguments passed to the stack, this space must be allocated before pushing the arguments. If the function returns any value, this is done by moving the returned value to the E register before returning. In cases where multiple values are returned, the callee will push each value to the stack in places of shadow space and then move the amount of returned values to the E register. The standard library will always be following these conventions. Shadow Space Shadow space refers to some reserved space on the stack that can be used by a callee to modify stack space when returning without the VM noticing and complaining about it. This is used in the default calling convention for returning multiple values on the stack and avoiding any safety checks the VM may perform. Shadow space on the stack can also serve other purposes, such as: Editing passed arguments : By allocating shadow space before passing arguments to the stack, the callee is allowed to initialize some of this space with a modified value, thus changing it. This strategy can be used to successfully pass arguments by reference if needed. Buffer and Data Storage : In some situations, the caller may want to see the data the callee used without actually returning it. This is useful for ensuring the data is right and debugging the function. Exception Handling : For functions that may throw an exception, it's important to reserve shadow space for the internal exception handler to use for storing possibly important information as well as the exception details. This is done so the caller may catch and handle the exception if the shadow space isn't clean after the function call. The reason the internal handler doesn't allocate its own stack space is because the VM is strictly not allowed to modify any data accessible to the programmer internally. The standard library mostly doesn't require this, but if it does, it will be well documented as to what to do. Storing Data The CTVM has 4 different ways of storing data: stack , heap , scope , and registers . These all have their pros and cons depending on how you wish to use your data. The Stack The stack is the most common place to store data. It's fast, efficient, and doesn't have any special code. It has 4 built-in instructions to manipulate it: push : Will add a new value to the top of the stack. pop : Will remove the top value on the stack and put it in a register or fully delete it. get : Will get a copy of a stack value at an offset and put it in a register. dup : Will duplicate the top of the stack. The Heap The heap is like the heap used on native compiled languages such as C, C++, and Rust, but this one is virtual and managed by the VM, so memory leaks will be detected and cleaned up. It's useful in case a function wants to allocate some special data and return it. The heap has 4 built-in instructions to manipulate it: alloc : Will allocate a value worth of space on the heap and put the address of it in the H register. free : Will remove and free a value from the heap with the address stored in the H register. Undefined behavior if the address doesn't actually point to somewhere on the heap. read : Will read a value on the heap with the address stored in the H register and put it in a register. Undefined behavior if the address doesn't actually point to somewhere on the heap. write : Will pop the stack and write that value to the heap on address, which is stored in the H register. Undefined behavior if the address doesn't actually point to somewhere on the heap. The Varscope The variable scope isn't really useful for much since it requires searching every time a variable is accessed. The only use is for named values. It has 5 built-in instructions. The Registers The registers are the most important part of the VM and your program. They hold any data and are the fastest to access. They are also used for most other instructions to even work. There are 2 built-in register instructions: move : Will move a new value into a register. copy : Will copy the value of one register to another. Immediate Values When data is used directly in an instruction, it's called an immediate. These are automatically typed unlike the data section which requires implicitly specifying the type of a data. When an immediate is used, the VM or compiler may choose to cache it so it's faster to access if it's being used multiple times. Strings A string in the CTVM is a 16 byte structure which consists of 2 parts: a pointer to the c-string and the size of the string. Strings are be default immutable unless special standard functions are used to edit it. Arrays There's currently no built-in way to have arrays other than pushing the elements to the stack and knowing the offsets at all times, but this approach is potantially dangerous since the stack is a fixed size of around 1 megabyte. Instructions Instructions are the main thing that run your program. There's many different and they all perform different operations. An instruction consists of the opcode (push, pop, etc.) and some arguments separated by commas depending on the opcode. Full list of instructions . Statements and Expressions This expects you know all the instructions. If main: { move regB, 69 move regC, 420 comp eq, regB, regC move regA, \"println\" jit if_true, regB move regC, \"they are not equal\" call goto if_end if_true: move regC, \"they are equal\" call if_end: move regE, 0 exit regE } This snippet jumps to if_true if 69 == 420 and runs some other code that goes to if_end if it's not equal. There's many ways to do this, but this is my preferred way. For Loops main: { move regA, \"println\" move regE, 10 // amount of iterations move regF, 0 L1: copy regF, regC call move regC, 1 add regF, regC copy regB, regF comp lte, regF, regE // regF <= regE (10) jit L1, regB move regE, 0 exit regE } This snippet is the CTASM equivalent of: for (int i = 0; i <= 10; i++) { println(i); } Do While Loops main: { move regA, \"println\" move regB, 1 L1: move regC, \"spam\" call jit L1, regB // Unreachable move regE, 0 exit regE } This snippet if the CTASM equivalent of: do { println(\"spam\"); } while (1); While Loops main: { move regA, \"println\" move regB, 1 goto L1 CL1: move regC, \"spam\" call L1: jit CL1, regB } This snippet is the CTASM equivalent of: while (1) { println(\"spam\"); }","title":"Getting Started"},{"location":"gettingstarted/#hello-world","text":"Your first program which prints hello world: #entry main #section data hello: str \"hello world\" println: str \"println\" #section code main: { move regA, println move regC, hello call move regE, 0 exit regE } Copy this code into hello.ctasm and compile with ctasm -c hello.ctasm && ./out . The -c flag means compile to native C. Congratulations! You just compiled and ran your first CTASM program; however, this code can be hard to comprehend for a beginner. Let's look deeper into the program, line by line: #entry main : This tells the VM what function to call at the start of your program. #section data : This declares all the code below it as \"data\", or static variables. More on sections will be explained later on. hello: str \"hello world\" : This makes a variable named hello of type string and the value \"hello world\". println: str \"println\" : This makes a variable named println of type string and the value \"println\". This is just used to store the println function name, as it's needed when calling it. #section code : This declared all the code below it as the actual program code. Functions and instructions are declared and written here. More on sections later on. main: { : This declares a function named main and opens a block for all instructions within this function. A block is just a simple {} , just like most other languages. move regA, println : This moves the println data into the A register, which is used for function calling. move regC, hello : This moves the hello data into the C register, which stores the first argument for println . Functions and calling conventions are explained in detail later on. call : This will search for and (if found) call the function whose name is stored in the A register. move regE, 0 : This just moves the 0 constant into the E register. exit regE : This exits the program with the code contained in the E register (in this case, 0). Exiting is required for CTASM programs; otherwise, the VM will complain. } : This marks the end of the main function.","title":"Hello World"},{"location":"gettingstarted/#compiling-multiple-files","text":"If you want to compile and use multiple files, you must simply provide them all in the ctasm command, and it will automatically compile and link each file to whatever your target output is. To use data and code from these other files, you don't have to do any importing since all files automatically include each other safely to make it even easier to use, but you can still implicitly say you're using a separate file by adding #using \"otherfile.ctasm\" at the top of your file using it. This just tells the compiler to error if the file isn't found in the list of files to compile.","title":"Compiling Multiple Files"},{"location":"gettingstarted/#sections","text":"CTASM uses sections to organize code into different sections. This is done in a similar manner to assembly which does the same thing. There are currently 2 different sections in CTASM: code and data . Data - is used to store any static variables in memory before the program even starts. The way this is actually done is dependant on what it compiles to and the implementation of said compiler. Code - is the only required section since it is used to define all the functions and instructions for your code. A section is declared using #section <name> . Detailed explanations of all sections .","title":"Sections"},{"location":"gettingstarted/#compiler-directives","text":"Compiler directives are important pieces of code that are used to tell the compiler how to generate the code. This can be anything ranging from which specific version it's using and the entry function to the file name to use in the outputted code and what other files are being used. Directives are defined with a # followed by its name and argument(s). For directives, arguments are only separated by a space and an argument encased in double quotes (\"many words\") will count as one argument. Full list of directives .","title":"Compiler Directives"},{"location":"gettingstarted/#comments","text":"// one line comment /* multi line comment */","title":"Comments"},{"location":"gettingstarted/#functions","text":"main: { move regA, \"add\" // function name move regC, 34 // x move regD, 35 // y call copy regE, regC move regA, \"println\" // print value call move regE, 0 exit regE } add: { // x, y add regC, regD // IMPORTANT: add here is the INSTRUCTION. it has NOTHING to do with the functions name copy regB, regE // conventions soon return } At their core, functions are really simple. They just run instructions. There's no automatic type checking or argument counting here without the use of some standard functions. However, you should still follow the calling convention and (optionally) declare the arguments in a comment. Technically , you can overload a function, but it completely overloads it, meaning the lowest definition of the function is the one used at the end.","title":"Functions"},{"location":"gettingstarted/#hoisting","text":"Functions can be used before they're declared: add is declared after main , but is still being used within it. This is due to the VM loading all functions into memory before running.","title":"Hoisting"},{"location":"gettingstarted/#calling-convention","text":"By default, the CTASM calling convention passes the first 4 arguments through registers C , D , F , and G in that order. Arguments beyond the fourth get pushed to the stack following a left-to-right order. If the function uses a variable number of arguments (REST parameters or varargs), they should be pushed onto the stack from left to right, followed by the count of REST parameters. Even when there's less than 4 regular arguments, REST parameters should still only be on the stack. REST parameters should always come after the normal arguments. The callee (the function being called) is always responsible for clearing the passed arguments and restoring the stack to its state before being called. This will optionally be enforced by the caller (the instruction doing the call). The caller may optionally allocate shadow space on the stack for the callee; however, if this is done, the caller is also responsible for removing this shadow space after the function call. If the function needs arguments passed to the stack, this space must be allocated before pushing the arguments. If the function returns any value, this is done by moving the returned value to the E register before returning. In cases where multiple values are returned, the callee will push each value to the stack in places of shadow space and then move the amount of returned values to the E register. The standard library will always be following these conventions.","title":"Calling Convention"},{"location":"gettingstarted/#shadow-space","text":"Shadow space refers to some reserved space on the stack that can be used by a callee to modify stack space when returning without the VM noticing and complaining about it. This is used in the default calling convention for returning multiple values on the stack and avoiding any safety checks the VM may perform. Shadow space on the stack can also serve other purposes, such as: Editing passed arguments : By allocating shadow space before passing arguments to the stack, the callee is allowed to initialize some of this space with a modified value, thus changing it. This strategy can be used to successfully pass arguments by reference if needed. Buffer and Data Storage : In some situations, the caller may want to see the data the callee used without actually returning it. This is useful for ensuring the data is right and debugging the function. Exception Handling : For functions that may throw an exception, it's important to reserve shadow space for the internal exception handler to use for storing possibly important information as well as the exception details. This is done so the caller may catch and handle the exception if the shadow space isn't clean after the function call. The reason the internal handler doesn't allocate its own stack space is because the VM is strictly not allowed to modify any data accessible to the programmer internally. The standard library mostly doesn't require this, but if it does, it will be well documented as to what to do.","title":"Shadow Space"},{"location":"gettingstarted/#storing-data","text":"The CTVM has 4 different ways of storing data: stack , heap , scope , and registers . These all have their pros and cons depending on how you wish to use your data.","title":"Storing Data"},{"location":"gettingstarted/#the-stack","text":"The stack is the most common place to store data. It's fast, efficient, and doesn't have any special code. It has 4 built-in instructions to manipulate it: push : Will add a new value to the top of the stack. pop : Will remove the top value on the stack and put it in a register or fully delete it. get : Will get a copy of a stack value at an offset and put it in a register. dup : Will duplicate the top of the stack.","title":"The Stack"},{"location":"gettingstarted/#the-heap","text":"The heap is like the heap used on native compiled languages such as C, C++, and Rust, but this one is virtual and managed by the VM, so memory leaks will be detected and cleaned up. It's useful in case a function wants to allocate some special data and return it. The heap has 4 built-in instructions to manipulate it: alloc : Will allocate a value worth of space on the heap and put the address of it in the H register. free : Will remove and free a value from the heap with the address stored in the H register. Undefined behavior if the address doesn't actually point to somewhere on the heap. read : Will read a value on the heap with the address stored in the H register and put it in a register. Undefined behavior if the address doesn't actually point to somewhere on the heap. write : Will pop the stack and write that value to the heap on address, which is stored in the H register. Undefined behavior if the address doesn't actually point to somewhere on the heap.","title":"The Heap"},{"location":"gettingstarted/#the-varscope","text":"The variable scope isn't really useful for much since it requires searching every time a variable is accessed. The only use is for named values. It has 5 built-in instructions.","title":"The Varscope"},{"location":"gettingstarted/#the-registers","text":"The registers are the most important part of the VM and your program. They hold any data and are the fastest to access. They are also used for most other instructions to even work. There are 2 built-in register instructions: move : Will move a new value into a register. copy : Will copy the value of one register to another.","title":"The Registers"},{"location":"gettingstarted/#immediate-values","text":"When data is used directly in an instruction, it's called an immediate. These are automatically typed unlike the data section which requires implicitly specifying the type of a data. When an immediate is used, the VM or compiler may choose to cache it so it's faster to access if it's being used multiple times.","title":"Immediate Values"},{"location":"gettingstarted/#strings","text":"A string in the CTVM is a 16 byte structure which consists of 2 parts: a pointer to the c-string and the size of the string. Strings are be default immutable unless special standard functions are used to edit it.","title":"Strings"},{"location":"gettingstarted/#arrays","text":"There's currently no built-in way to have arrays other than pushing the elements to the stack and knowing the offsets at all times, but this approach is potantially dangerous since the stack is a fixed size of around 1 megabyte.","title":"Arrays"},{"location":"gettingstarted/#instructions","text":"Instructions are the main thing that run your program. There's many different and they all perform different operations. An instruction consists of the opcode (push, pop, etc.) and some arguments separated by commas depending on the opcode. Full list of instructions .","title":"Instructions"},{"location":"gettingstarted/#statements-and-expressions","text":"This expects you know all the instructions.","title":"Statements and Expressions"},{"location":"gettingstarted/#if","text":"main: { move regB, 69 move regC, 420 comp eq, regB, regC move regA, \"println\" jit if_true, regB move regC, \"they are not equal\" call goto if_end if_true: move regC, \"they are equal\" call if_end: move regE, 0 exit regE } This snippet jumps to if_true if 69 == 420 and runs some other code that goes to if_end if it's not equal. There's many ways to do this, but this is my preferred way.","title":"If"},{"location":"gettingstarted/#for-loops","text":"main: { move regA, \"println\" move regE, 10 // amount of iterations move regF, 0 L1: copy regF, regC call move regC, 1 add regF, regC copy regB, regF comp lte, regF, regE // regF <= regE (10) jit L1, regB move regE, 0 exit regE } This snippet is the CTASM equivalent of: for (int i = 0; i <= 10; i++) { println(i); }","title":"For Loops"},{"location":"gettingstarted/#do-while-loops","text":"main: { move regA, \"println\" move regB, 1 L1: move regC, \"spam\" call jit L1, regB // Unreachable move regE, 0 exit regE } This snippet if the CTASM equivalent of: do { println(\"spam\"); } while (1);","title":"Do While Loops"},{"location":"gettingstarted/#while-loops","text":"main: { move regA, \"println\" move regB, 1 goto L1 CL1: move regC, \"spam\" call L1: jit CL1, regB } This snippet is the CTASM equivalent of: while (1) { println(\"spam\"); }","title":"While Loops"},{"location":"instructions/","text":"","title":"Instructions"},{"location":"sections/","text":"","title":"Sections"}]}